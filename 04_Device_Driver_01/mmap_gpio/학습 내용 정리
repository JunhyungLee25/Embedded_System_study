# mmap 기반 GPIO 제어 실습 정리

크로스 컴파일(Cross Compile)은 성능이 좋은 PC(Host)에서 실행 환경이 다른 타겟 보드(Raspberry Pi)용 프로그램을 만드는 과정이다.

`$ aarch64-linux-gnu-gcc –o [program_name] [file_name].c`

## 1. 개요
- 커널 모드 드라이버를 작성하기 전, 사용자 영역에서 `/dev/mem`과 `mmap`을 이용해 하드웨어 레지스터를 직접 조작하며 구조를 이해한다.

## 2. 코드별 핵심 포인트

### (1) LED 제어 (led_mmap.c - p.93)
- **목적**: GPIO 4번 핀에 연결된 LED를 ON/OFF 함.
- **주요 로직**:
    1. `/dev/mem` 파일을 `O_RDWR | O_SYNC` 모드로 오픈.
    2. `mmap`을 통해 GPIO 물리 주소를 가상 주소 `gpio` 포인터에 매핑.
    3. `gpio[GPFSEL0 / 4] |= (1 << 12);`: 핀 모드를 출력(Output)으로 설정.
    4. `GPSET0`에 비트를 쓰면 3.3V(ON), `GPCLR0`에 쓰면 0V(OFF).

### (2) 버튼 입력 감지 (button_mmap.c - p.94)
- **목적**: GPIO 17번 핀의 상태를 읽어 버튼 눌림을 확인.
- **주요 로직**:
    1. `GPFSEL1` 레지스터 조작으로 핀을 입력(Input) 모드로 설정.
    2. `while(1)` 루프에서 `GPLEV0` 레지스터의 17번째 비트 값을 Polling 방식으로 감시.
    3. `usleep(10000)`을 주어 CPU 부하를 방지하고 소프트웨어적 디바운싱 효과 부여.

### (3) 키보드 연동 제어 (keyboard_mmap.c - p.95)
- **목적**: 키보드 입력(1, 0, q)에 따라 실시간 하드웨어 제어.
- **핵심 기술**: `termios.h`
    - `ICANON` 비트를 해제하여 **Non-canonical 모드**로 전환 (엔터 입력 없이 즉시 처리).
    - `ECHO` 비트 해제로 입력한 글자가 화면에 중복 표시되지 않게 설정.

## 3. 현업 개발자의 통찰 (Insight)
- **장점**: 별도의 드라이버 설치 없이 빠른 하드웨어 검증 가능.
- **단점**: 
    - 보안상 취약함 (사용자 프로세스가 물리 메모리에 직접 접근).
    - 인터럽트(Interrupt) 처리가 어려워 Polling 방식만 사용 가능 (CPU 자원 낭비).
- **결론**: 실제 BSP 개발 시에는 이 mmap 원리를 **커널 내부**에서 구현하여 사용자에게 표준 인터페이스(`read/write/ioctl`)를 제공하는 '디바이스 드라이버'를 만들어야 함.


## mmap란?

mmap (Memory Mapping)
`mmap`은 하드웨어의 실제 주소(물리 주소)를 내 프로그램의 주소(가상 주소)로 '지도 그리기(Mapping)' 하듯이 연결하여, 마치 내 메모리처럼 직접 만질 수 있게 해주는 함수이다.

### 1. `mmap`은 왜 필요한가요?

원래 리눅스에서 하드웨어 레지스터(물리 주소)는 **커널(Kernel)** 만 접근할 수 있다. 사용자 프로그램(User Space)은 원칙적으로 하드웨어를 직접 건드릴 수 없다.

하지만 매번 하드웨어 값을 하나 읽으려고 커널에 부탁(`시스템 콜` 호출)하는 과정은 속도가 느리고 번거롭다. 이때 `mmap`을 사용하면 커널의 성역인 특정 물리 주소 영역을 내 프로그램의 주소 공간으로 **'소환'** 해올 수 있다.

### 2. 쉬운 비유: "직통 전화 개설"

- **일반 방식**: 하드웨어라는 사장님께 보고를 하려면 비서(커널)를 거쳐서 서류를 전달하고 답변을 기다려야 합니다. (느림)
    
- **mmap 방식**: 내 책상 위에 사장님과 바로 연결되는 **직통 전화(매핑된 메모리)** 를 설치하는 것과 같습니다. 비서를 거치지 않고 바로 대화할 수 있죠. (매우 빠름)
    

### 3. 실습 코드에서의 역할 (강의자료 93p~95p)

우리가 지난번에 작성한 LED, 버튼 코드에서 `mmap`이 쓰인 이유는 다음과 같습니다.

1. `/dev/mem`이라는 '물리 메모리 전체'를 의미하는 파일을 엽니다.
    
2. `mmap`을 통해 "GPIO 레지스터가 있는 물리 주소(`0xFE200000` 등)를 내 포인터 변수 `gpio`에 연결해줘!"라고 요청합니다.
    
3. 이후에는 `*gpio = 0x01;` 처럼 포인터에 값을 쓰는 것만으로도 **실제 하드웨어의 전압을 바꿀 수 있게** 됩니다.
## 1. 정의
- 파일이나 장치를 프로세스의 가상 메모리 공간에 매핑하는 시스템 콜.

## 2. 임베디드에서의 용도
- `/dev/mem`과 함께 사용하여 하드웨어 레지스터(GPIO, I2C 등)의 물리 주소에 직접 접근하기 위해 사용.
- 커널 드라이버를 거치지 않고 사용자 영역에서 빠른 하드웨어 제어가 가능함.

## 3. 주요 인자 (함수 원형)
- `void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);`
- `fd`: 접근할 파일 (주로 `/dev/mem`)
- `offset`: 매핑할 실제 하드웨어의 물리 주소
- `length`: 매핑할 영역의 크기 (보통 페이지 단위인 4KB)

## homework

- GPIO Toggle & Keyboard Control (Robust Version)

## 1. 개요
- **목적**: GPIO 17(Input)과 GPIO 4(Output)를 연동하여 버튼 토글 기능 구현 및 안전한 종료 처리.
- **참고 자료**: 실습 강의자료 134-135페이지 (GPIO Register Map), 리눅스 코멘토 정리본 1페이지.

## 2. 코드 변형 및 발전 사항
| 구분        | 이전 실습 코드      | 발전된 숙제 코드        | 이유 (Robustness)                      |
| :-------- | :------------ | :--------------- | :----------------------------------- |
| **비트 설정** | `(1 << n)`    | `&= ~(7 << n)`   | 하드웨어의 이전 설정값을 완전히 초기화하여 오작동 방지`      |
| **초기화**   | 정의되지 않음       | 명시적 `GPCLR0` 호출  | 프로그램 시작 시 장치 상태를 예측 가능하게 확정          |
| **종료 처리** | `Ctrl+C` (강제) | 'q' 키 입력 (정상 종료) | 메모리 매핑 해제 및 터미널 복구를 통해 시스템 안정성 확보    |
| **토글 방식** | 단순 상태 출력      | `flag` 변수 활용     | 사용자가 버튼을 누를 때마다 LED 상태를 반전시키는 실무적 로직 |


## 3. 핵심 코드 분석
- **Bit Masking**: `tmp = gpio[GPLEV0 / 4] & (1 << 17);`
  - 32비트 레지스터 데이터 중 17번 비트의 값만 추출하여 버튼 상태 파악.
- **Edge Detection**: `if (tmp != prev)`
  - 무한 루프 내에서 상태가 변하는 '찰나'를 포착하여 중복 실행 방지.
- **Memory Mapping**: `/dev/mem`을 `mmap`하여 사용자 영역에서 하드웨어 레지스터에 직접 접근.

## 4. 주의 사항 및 팁
- **Sudo 권한**: `/dev/mem` 접근을 위해 반드시 `sudo ./homework`로 실행해야 함.
- **Debouncing**: 현재 코드에 `usleep(50000);`을 추가하면 버튼의 물리적 떨림(채터링)을 완벽히 잡을 수 있음.

## Zmodem 대신 사용 : Base64 복사-붙여넣기

1. **Ubuntu 터미널에서:**
	
    ```
    base64 homework > homework.txt
    cat homework.txt
    ```
    
    - 화면에 뜬 긴 텍스트를 **모두 복사**.
        
1. **Minicom(정상 화면)에서:**
    
    ```
    cat > homework.txt
    ```
    
    - 마우스 **우클릭으로 붙여넣기** 한 후, **Ctrl + D**를 눌러 저장.
        
1. **보드에서 복원:**
    
    ```
	base64 -d homework.txt > homework
    chmod +x homework
    ./homework
    ```
